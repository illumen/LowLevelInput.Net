using System;

/*
 * shellcode with x64 and x86 support
 * 
 * hooks several Suspend methods to prevent backlisted threads from being suspended
 * 
 * c++ shellcode definition at the end of the file
*/

namespace LowLevelInput.DebuggerSupport
{
    internal static class Shellcode
    {
        private static bool _x64 = IntPtr.Size != 4;

        /// <summary>
        /// returns the shellcode with the current process bitness
        /// </summary>
        /// <returns></returns>
        public static byte[] GetShellcode()
        {
            if(_x64)
            {
                return _get_shellcode_x64();
            }
            else
            {
                return _get_shellcode_x86();
            }
        }

        /// <summary>
        /// Gets the original placeholder offset.
        /// </summary>
        /// <returns></returns>
        public static int GetOriginalPlaceholderOffset()
        {
            return _x64 ? 10 : 9;
        }

        /// <summary>
        /// Gets the offset for the GetThreadId winapi method in the stub.
        /// </summary>
        /// <returns></returns>
        public static int GetThreadIdPlaceholderOffset()
        {
            return _x64 ? 25 : 16;
        }

        /// <summary>
        /// Gets the blacklist placeholder offset.
        /// </summary>
        /// <returns></returns>
        public static int GetBlacklistPlaceholderOffset()
        {
            return _x64 ? 40 : 23;
        }

        /// <summary>
        /// Gets the blacklist size placeholder offset.
        /// </summary>
        /// <returns></returns>
        public static int GetSizePlaceholderOffset()
        {
            return _x64 ? 55 : 30;
        }

        private static byte[] _get_shellcode_x64()
        {
            return new byte[]
            {
                0x89, 0x4C, 0x24, 0x08, 0x48, 0x83, 0xEC, 0x68, 0x48, 0xB8, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
                0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0xB8, 0xBE, 0xBA, 0xFE, 0xCA, 0xBE, 0xBA, 0xFE, 0xCA,
                0x48, 0x89, 0x44, 0x24, 0x50, 0x48, 0xB8, 0xAD, 0xDE, 0xAD, 0xDE, 0xAD, 0xDE, 0xAD, 0xDE,
                0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0xB8, 0xEF, 0xBE, 0xEF, 0xBE, 0xEF, 0xBE, 0xEF, 0xBE,
                0x48, 0x89, 0x44, 0x24, 0x38, 0x83, 0x7C, 0x24, 0x70, 0x00, 0x75, 0x0A, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0x95, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x44, 0x24, 0x50, 0x48, 0x89, 0x44, 0x24, 0x58, 0x48, 0x83, 0x7C, 0x24, 0x40, 0x00, 0x74, 0x08, 0x48, 0x83, 0x7C, 0x24, 0x38, 0x00, 0x75, 0x0A, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x54, 0x24, 0x30, 0xEB, 0x67, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x8B, 0x00, 0x89, 0x44, 0x24, 0x24, 0x83, 0x7C, 0x24, 0x24, 0x00, 0x75, 0x0A, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x54, 0x24, 0x30, 0xEB, 0x4B, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x54, 0x24, 0x58, 0x89, 0x44, 0x24, 0x28, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0A, 0x8B, 0x44, 0x24, 0x20, 0xFF, 0xC0, 0x89, 0x44, 0x24, 0x20, 0x8B, 0x44, 0x24, 0x24, 0x39, 0x44, 0x24, 0x20, 0x7D, 0x19, 0x48, 0x63, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0x8B, 0x54, 0x24, 0x28, 0x39, 0x14, 0x81, 0x75, 0x04, 0x33, 0xC0, 0xEB, 0x0A, 0xEB, 0xD3, 0x8B, 0x4C, 0x24, 0x70, 0xFF, 0x54, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x68, 0xC3, 0xCC, 0x48, 0x83, 0xEC, 0x38, 0xB9, 0x39, 0x05, 0x00, 0x00, 0xE8, 0x02, 0xFF, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x20, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x38, 0xC3
            };
        }

        private static byte[] _get_shellcode_x86()
        {
            return new byte[]
            {
                0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x24, 0xC7, 0x45, 0xE8, 0xFE, 0xFE , 0xFE , 0xFE,
                0xC7 , 0x45 , 0xE4 , 0xBE , 0xBA , 0xFE , 0xCA ,
                0xC7 , 0x45 , 0xEC , 0xAD , 0xDE , 0xAD , 0xDE ,
                0xC7 , 0x45 , 0xF4 , 0xEF , 0xBE , 0xEF , 0xBE ,
                0x83 , 0x7D , 0x08 , 0x00 , 0x75 , 0x08 , 0x83 , 0xC8 , 0xFF , 0xE9 , 0x83 , 0x00 , 0x00 , 0x00 , 0x8B , 0x45 , 0xE8 , 0x89 , 0x45 , 0xF8 , 0x8B , 0x4D , 0xE4 , 0x89 , 0x4D , 0xE0 , 0x83 , 0x7D , 0xEC , 0x00 , 0x74 , 0x06 , 0x83 , 0x7D , 0xF4 , 0x00 , 0x75 , 0x0C , 0x8B , 0x55 , 0x08 , 0x52 , 0xFF , 0x55 , 0xF8 , 0x83 , 0xC4 , 0x04 , 0xEB , 0x5F , 0x8B , 0x45 , 0xF4, 0x8B, 0x08, 0x89, 0x4D, 0xF0, 0x83, 0x7D, 0xF0, 0x00, 0x75, 0x0C, 0x8B, 0x55, 0x08, 0x52, 0xFF, 0x55, 0xF8, 0x83, 0xC4, 0x04, 0xEB, 0x45, 0x8B, 0x45, 0x08, 0x50, 0xFF, 0x55, 0xE0, 0x83, 0xC4, 0x04, 0x89, 0x45, 0xDC, 0xC7, 0x45, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0x4D, 0xFC, 0x83, 0xC1, 0x01, 0x89, 0x4D, 0xFC, 0x8B, 0x55, 0xFC, 0x3B, 0x55, 0xF0, 0x7D, 0x14, 0x8B, 0x45, 0xFC, 0x8B, 0x4D, 0xEC, 0x8B, 0x14, 0x81, 0x3B, 0x55, 0xDC, 0x75, 0x04, 0x33, 0xC0, 0xEB, 0x0C, 0xEB, 0xDB, 0x8B, 0x45, 0x08, 0x50, 0xFF, 0x55, 0xF8, 0x83, 0xC4, 0x04, 0x8B, 0xE5, 0x5D, 0xC3
            };
        }
    }
}

//       typedef unsigned int (* GetThreadId_t) (unsigned int hThread);
//       typedef unsigned int (* SuspendResume_t) (unsigned int hThread);

//       __declspec(noinline) unsigned int _hk_ResumeSuspend(unsigned int handle)
//       {
//           void* fn_original = (void*)0xFEFEFEFEFEFEFEFE;
//           void* fn_get_thread_id = (void*)0xCAFEBABECAFEBABE;
//           int* blacklist = (int*)0xDEADDEADDEADDEAD;
//           int* blacklist_size = (int*)0xBEEFBEEFBEEFBEEF;

//           if (!handle) return (unsigned int)-1;

//           auto call_original = reinterpret_cast<SuspendResume_t>(fn_original);
//           auto call_thread_id = reinterpret_cast<GetThreadId_t>(fn_get_thread_id);

//           if (!blacklist || !blacklist_size) return call_original(handle);

//           int size = *blacklist_size;

//           if (size == 0) return call_original(handle);

//           int current_thread_id = call_thread_id(handle);

//           for (int i = 0; i < size; i++)
//           {
//               if (blacklist[i] == current_thread_id) return (unsigned int)0;
//           }

//         return call_original(handle);
//      }